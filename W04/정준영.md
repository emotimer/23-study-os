# CH04

## 프로세스 생성(Process Create)

부포 프로세스가 자식 프로레스를 생성

이때 자식을 복수로 생성 할 수 있음

그래서 계층구조가 트리 형태로 생성

**자원 → 보통 운영체제로부터 받게 됨**

- 부모와 자식이 모든 자원을 공유하는 Model
- 일부를 공유하는 Model
- 전혀 공유하지 않는 Model
- \*\* 원칙적으로, 일반적으로는 공유하지 않음. 자식이 생성되면 cpu와 memory를 얻기 위해 경쟁을 하게 됌.
- 리눅스처럼 효율적인 운영체제는 전부 copy하는 것이 아닌 내용이 달라지기 시작할때 copy를 하여 독립적인 자원을 가져간다. (copy-on-write COW) write 발생시 copy를 하겠다는 의미. 이전까지는 공유하겠다.

**수행(Execution)**

- 부모와 자식이 공존하며 수행되는 모델
- 자식이 종료될때까지 부모가 기다리는 모델

**주소공간**

- 자식은 부모의 공간을 복사함
- 자식은 그 공간에 새로운 프로그램을 올림

—> **일단 1)복제를 하고 새로운 프로그램으로 2)덮어 쓴다.**

복제의 기능을 수행하는 것 → fork()

다른 프로그램으로 필요한 것만 덮어 씌우는 것 → exec()

**유닉스의 예시**

fork() 시스템 콜이 새로운 프로세스를 생성

- 부모를 그대로 복사
- 주소 공간 할당
- fork 다음에 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리 할당

운영체제를 통해서만 새로운 프로세스를 생성할 수 있음.

---

## 프로세스 종료

- 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌

**exit** → (C언어의 예시 마지막 코드블럭 닫는 기호를 보면 컴파일러가 자동으로 exit()를 묵시적으로 추가해줌.) <보통 자발적으로 종료>

- 자식이 부모에게 output data를 보냄(via wait).
- 프로세스의 각종 자원들이 운영체제에게 반납함.

- 부모 프로세스가 자식의 수행을 종료시킴 (abort)
  - 자식이 할당 자원의 한계치를 넘어섬
  - 자식에게 할당된 task가 더 이상 필요하지 않음
  - 부모가 종료(exit)하는 경우
    - 운영체제는 부모 프로세스가 종료하는 경우 자식이 더이상 수행되도록 두지 않는다. <프로세스가 하나 종료될 때 가장 마지막 자식부터 kill 하고 단계적으로 종료 시킨다.>
    - 단계적인 종료로 **“종료”**가 수행

---

## fork() 시스템 콜

부모 프로세스에서 fork()를 만나면 자식 프로세스를 생성하고, 이후 자신의 코드를 실행. 자식 프로세스도 fork()이후 코드를 실행하게 됌.

운영체제는 fork()이후의 자식과 부모를 구분할 수 있는 pid를 리턴해준다.

부모 프로세스는 결과값이 양수이고, 자식은 0이 리턴된다.

그래서 pid값에 따라 부모와 자식에게 시킬 task를 구분할 수 있다.

fork() 이전 코드는 부모만 실행할 수 있다.

---

## exec() 시스템콜

execlp()을 만나면 이전의 코드를 잊고, 해당 경로내의 program으로 덮어 쓰여지게 되고, 해당 프로그램의 main함수부터 실행 된다.

- 꼭 fork()를 하지 않고서도 exec를 할 수도 있다. 그러나 exec이후의 코드들은 실행할 수 없다. 이미 새로운 프로그램으로 덮어 씌워졌기 때문이다.

---

## wait 시스템 콜

- 프로세스 A가 wait() 시스템 콜을 호출하면

  - 커널은 child가 종료될 때까지 프로세스 A를 sleep 시킨다(blook 상태)
  - child process가 종료되면 커널은 프로세스 A를 깨운다(ready 상태)
  - 부모는 자식의 종료까지 기다린다.

- 대표적인 wait 시스템 콜을 하는 예시는 명령프롬포트를 통한 프로그램 실행.
- 예시 ) Terminal에 프로그램 이름을 치고, 실행되고, 종료되면 다시 Terminal (shell)로 돌아오는 과정이 해당 위의 과정. Terminal은 자식프로세스의 종료를 wait()하고 자식이 종료되면 다시 실행되면서 입력을 기다리게 된다.

---

## exit() 시스템 콜

- **프로세스의 종료**
  - 자발적 종료
    - 마지막 문장을 수행 후 exit()를 통해 종료
    - 프로그램에 명시적으로 적어주지 않아도 main 리턴 위치의 컴파일러가 넣어준다.
  - 비 자발적 종료
    - 부모가 자식 프로세스를 강제로 종료시킴
      - 자식이 한계치를 넘기는 자원 요청
      - 자식에게 할당된 태스크가 더이상 필요 x
    - 키보드로 kill, break를 친 경우
    - 부모가 종료하는 경우
      - 부모 프로세스가 종료하기 전에 자식들이 먼저 종료됨

---

## 프로세스와 관련한 시스템 콜

- fork() - create a child(copy)
- exec() - overaly new image
- wait() - sleep untill child is done
- exit() - frees all the resources, notify parent

## 프로세스 간 협력

**독립적 프로세스**

프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스가 다른 프로세스 수행의 영향을 미치지 못함

**협력 프로세스**

프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음

**프로세스 간 협력 메커니즘 = IPC**

메시지를 전달하는 방법

Message passing - 커널을 통한 메시지 전달

주소 공간을 공유하는 방법

Shared memory - 서로 다른 프로세스 간에도 일부 주소공간을 공유하게 하는 메커니즘

Thread - thread는 사실상 하나의 프로세스이므로 프로세스간 협력으로 보기에는 어렵지만 하나의 process를 성하는 thread간에는 주소공간을 공유하므로 협력 가능 (참고)

### Message Passing

1. Message System
   - 프로세스 사이에 공유 변수를 일체 사용하지 않고 통신하는 시스템
2. Direct Commnication
   - 통신하려는 프로세스의 이름을 명시적으로 표시
3. indirect Communication
   - mailbox 또는 port를 통해 메시지 간접 전달

---

## CPU 스케줄링

CPU bursts - cpu 작업

IO bursts - io 작업

**I.O bound job**

- cpu를 아주 짧게 사용하고 중간에 io가 끼어드는 작업. 대신 사용 빈도가 잦다.

**CPU bound job**

- cpu를 진득하게 많이 사용하는 작업

프로그램은 위의 job들이 섞여있다.

cpu 스케줄링이 필요한 이유는 i.o bound job은 사람과 상호작용하는 작업이 많기에 이 작업들에 cpu를 적절히 할당해 줄 필요가 있다.

---

### 프로세스의 특성 분류

프로세스는 특성에 따라 두 가지로 나눔.

1. **I.O bound process**

   cpu를 잡고 계산하는 시간보다 i.o에 많은 시간이 필요 job

   many short cpu bursts

2. **CPU bound process**

   계산 위주 job

   few very long CPU bursts - 즉 연속적으로 쓰는 시간이 길다.

---

### CPU 스케줄러

- Ready 상태의 프로세스 중에서 이번에 cpu를 줄 프로세스를 고른다.
- cpu를 누구에게 줄 것인가?

### Dispatcher

- cpu의 제어권을 cpu 스케줄러에 의해 선택된 프로세스에게 넘긴다.
- 이 과정을 context switch라고 한다.
- cpu를 주는 과정. 이것을 해주는 역할

**cpu 스케줄링이 필요한 경우는 프로세스에게 다음과 같은 상태변화가 있다. (언제 필요한가?)**

1. Running → Blocked (예. i.o작업 요청)
2. Running → Ready (예. 할당 시간 만료)
3. Blocked → Ready (예. i.o 완료후 인터럽트)
4. Terminate

preemptive - 강제로 빼았는것

nonpreemptive - 강제로 빼앗지 않고 자진 반납
