# Ch2

생성일: 2023년 1월 6일 오후 1:41

# 컴퓨터 시스템 구조

### Computer

- CPU
    - 메모리에서 명령어를 읽어서 실행하는 역할만 한다. 수행하고 interrupt line을 확인함.
- Memory
    - cpu의 작업 공간
- Register : 메모리보다 더 빠른 공간
- Mode bit : cpu에서 실행되는것이 운영체제인지 사용자 프로그램인지 구분지어준다.
- interrupt line : cpu는 항상 메모리에서 읽어온 명령어만 실행한다. i.o를 해야할때가 오면 컨트롤러에게 시키고, 다음 명령어를 수행한다. 이때 i.o장치가 자신의 작업이 완료된것을 알려주는 장치.
- timer : 특정 프로그램이 cpu를 독점하는것을 막는다. 추가적인 H.W로 cpu의 제어권을 관리한다. (무한 loop 프로그램 방지)

* 사용자 프로그램은 직접 i.o장치와 소통할수 없다. OS와 소통만 가능하다. 필요하다면 운영체제에게 CPU를 넘겨주어야 한다.

* interrupt가 발생하면 자동으로 cpu운영권이 OS에게 넘어온다. 이때 os는 interrupt를 살펴보고, 요청을 수행해준다.

### I/O device

- Disk (hard disk는 in and out 결과를 동시에 수행하는 장치)
- Printer
- Moniter
- keyBoard, Mouse

→ 각각의 i/o device는 해당 디바이스를 전담하는 작은 cpu같은 장치가 존재. device Controller. 각 i.o디바이스를 통제하는 역할은 cpu가 아니라 컨트롤러가 한다.

→ 해당 컨트롤러도 작업 공간이 필요함. 해당 공간을 localBuffer라고 한다.

→ disk가 cpu에 비해 느리기에 컨트롤러가 전담한다.

cpu는 매 클럭 사이클마다 메모리에서 instrouction(기계어)를 읽어서 실행하게 된다.

### Mode bit

→ 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호장치가 필요.

값 → 보안상의 이점이 있다.

- 0 : 운영체제가 cpu에서 실행중. 모든 일을 수행할 수 있는 환경이 세팅된다. 즉, 메모리, 디스크 모두 접근 가능함. (모니터 모드)
- 1 : 사용자 프로그램이 cpu에서 실행중. 제한된 일만 수행할 수 있는 환경이 세팅된다. 즉, 제한된 접근이 가능. 한정된 명령어만 수행 가능. (사용자 모드)

### Timer

- 특정 프로그램이 cpu를 독점하는것을 막기 위한 H.W장치.
- 운영체제는 사용자 프로그램을 cpu에게 할당할 때 Timer를 세팅한다.

### I.O device controller

- 해당 i.o 장치유형을 관리하는 일종의 작은 cpu
- 제어 정보를 위해 control register, status register를 가짐.
- local buffer를 가짐.

### DMA controller

- 직접 메모리를 접근할 수 있는 controller
- 원래는 메모리 접근은 cpu만 가능했는데, DMA도 접근 가능함.
- Need? → cpu가 너무 많은 interrupt를 당하기 때문에, 중간중간 작업을 CPU에게 interrupt를 걸고, 작업을 하는것이 overhead가 크기에 DMA가 작업을 대신 해줌. 그러면 CPU는 작업이 완료된 interrupt만 확인하게 되고, 효율적인 cpu사용이 가능.

Device Controller - 디바이스를 제어하기 위한 일종의 작은 cpu (H.W)

Device Driver - Os code중 각 장치별 처리 루틴. (S.W)

결론적으로 CPU는 매 순간마다 해야할 명령어만 실행한다. 

### 입출력(i.o)의 수행

- 모든 입출력 명령은 특권 명령
- 사용자 프로그램은 어떻게 i.o를 하는가? → os에게 부탁한다.
    - 시스템콜(System call) - 사용자 프로그램이 운영체제에게 i.o 요청. → 운영체제의 함수를 호출하는것은 단순히 사용자 프로그램의 메모리 주소를 바꾸는것으로 되는 것이 아님. → 직접 os단에 주소 점프를 못한다. os의 주소점프를 하기 위해서 프로그램이 직접 interrupt를 걸 수 있다. <의도적으로 인터럽트 라인을 세팅해야한다. 사용자 프로그램이 직접 점프할 수 없음>
    - trap을 사용하여 인터럽트 백터의 특정 위치로 이동
    - trap → s.w적인 interrupt이다. 사용자 프로그램이 Os에게 요청을 보내면서 제어를 넘긴다.
    - os는 올바른 요청인지 확인 후 i.o를 수행한다.
    - i.o를 요청하는건 trap. s.w적 인터룹트 다 끝나면 일반적 interrupt h.w적 인터룹트 발생
    - 인터룹트 백터 : 해당 인터럽트의 처리 루틴 주소를 갖고 있음. 번호와 해당 번호 루틴이 적힌 주소를 갖고 있다.
    - 인터럽트 처리 루틴 : 해당 인터럽트를 처리하는 커널 함수

---

---

- cpu의 레지스터에는 Program Counter가 존재. 수행해야할 명령어가 담긴 메모리를 가르키고 있음.
- cpu는 특별한 일이 없으면 순차적으로 명령어를 수행할 뿐이다.
- interrupt가 발생하면 제어는 운영체제에게 넘어간다.
- Mode bit에 따라서 수행할 수 있는 명령어가 달라진다.

## 동기식 입출력과 비동기식 입출력

- 동기식 입출력 (synchronous i.o) - 싱크로노스 입출력
    - i.o 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램으로 넘어감.
    
    → i.o를 요청하고 작업이 끝나야 사용자 프로그램이 다음 일을 할 수 있다. i.o작업의 결과를 확인할때까지 기다린다.
    
    - 구현 방법 1 → cpu도 낭비가 되지만, 매 순간 i.o장치도 하나만 동작할 수 있다.
        - i.o가 끝날 때까지 cpu를 낭비시킴
        - 매 시점 하나의 i.o만 일어날 수 있음
    - 구현 방법 2
        - i.o가 완료될 때까지 해당 프로그램에게서 cpu를 빼앗음
        - i.o 처리를 기다리는 줄에 그 프로그램을 줄 세움.
        - 다른 프로그램에게 cpu를 줌
        
- 비동기식 입출력(asynchronous i.o) - 에이싱크로노스 입출력
    
    → i.o작업을 던져두고, cpu를 얻어와서 바로 다음 일을 한다. i.o작업을 요청해두고 다른 작업을 하는 것.
    
    - i.o가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에게 즉시 넘어감.

- 두 경우 모두 i.o완료는 인터럽트로 알려줌.

## DMA (Direct Memory Access) - 메모리에 접근할 수 있는 장치 [작은 일들을 담당하는 장치]

- cpu가 잦은 인터럽트로 오버헤드가 커져서 이를 해결.
- DMA가 메모리에 작업을 완료하면 이를 cpu에 알려줌
- 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용한다.
- cpu의 중재 없이 device controller가 디바이스의 버퍼 내용을 메모리에 블럭 단위로 직접 전송.
- 바이트 단위가 아니라 블럭 단위로 인터럽트를 발생시킴
- ex) 만약 1바이트를 작성했다고 cpu에 인터럽트를 발생시키면 어마어마한 오버헤드가 발생함. 그러나 DMA가 블럭단위로 처리하고 이에 대한 인터럽트만 발생시키면 오버헤드를 줄일 수 있다.

## 서로 다른 입출력 명령어

cpu에는 메모리 접근하는 instruction이 있고

각 i.o 디바이스별로 별개의 instruction이 있어서 해당 명령어로 접근하는게 일반적.

- i.o를 수행하는 스페셜 instruction에 의해 - 메모리 접근하는 instruction 따로 있고, 각 i.o디바이스별로 메모리에 접근하는 별개의 instruction이 있음.
- Memort Mapped i.o에 의해 - i.o 장치도 메모리 주소에 연장 주소로 붙이고 접근하는 방법.

  

## 저장장치 계층구조

- Speed
- Cost
- Volatility - 휘발 유무

register - cache memory - main memory | magentic disk - optical disk - magentic tape

- speed가 빠르면 단위 공간당 가격이 비싸다.

## 프로그램의 실행 (메모리 load)

어떤 프로그램을 실행시키면 해당 프로그램의 독자적인 주소공간(가상 메모리)이 형성이 된다.

각 주소공간은 다시 code, data, stack등의 공간으로 나뉜다.

이가 가상메모리에 올라가고, 이후 실제 물리적 메모리에 올라가서 실행된다.

프로그램은 물리적 메모리에 모두 올리는것이 아니라, 당장 실행하는 코드만 물리적 메모리에 올린다. (메모리 낭비 방지) 

- Swap Area - 디스크 일정 공간을 메인 메모리처럼 사용

## 커널 주소 공간의 내용

- Code - 커널 코드 , 시스템콜, 인터럽트 처리코드, 자원관리를 위한 코드, 편리한 서비스 제공을 위한 코드
- Data - process - pcb, cpu등 각각의 h.w들은 이를 관리하기 위한 자료구조 존재.
- Stack - process 들의 커널스택

## 사용자 프로그램이 사용하는 함수

함수

1. 사용자 정의 함수
    - 자신의 프로그램에서 정의한 함수
2. 라이브러리 함수
    - 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수
    - 자신의 프로그램의 실행 파일에 포함되어 있다.
    
    → 1,2번은 실행파일을 만들면 해당 코드가 내 프로그램안에 포함되어 있다.
    
    → 호출 하더라도 해당 코드 블럭 내에서 점프해서 이동해서 실행
    
3. 커널함수
    - 운영체제 프로그램의 함수
    - 커널함수의 호출 - 시스템 콜
    
    → 내 프로그램안에는 정의가 없고 호출만 있다.
    

### 프로그램의 실행

User mode , Kernel mode의 조합으로 실행된다.

각 mode는 각자의 주소공간에서 실행됨.