# 05 - CPU Scheduling

### 종류

- 비선점형 : 다른 프로그램의 스케줄링을 뻇지 않는
- 선점형 : 뺏는

### Scheduling Criteria(척도)

- CPU Utilization : 가능한 바쁘게 사용할 것
- Throughput : 최대의 작업 처리 우선
- Turnarround time : 다쓰고 나갈떄까지의 시간이 짧은 것
- Waiting time : 대기 시간 (기다리는 시간의 총합)
- Response time : 개별적으로 기다리는 시간

## Schedulings

### FCFS (First-Come, First-Served)

- 먼저 온 작업을 먼저 실행하는
- 비 선점형
- Convoy Effect - 앞에 있는 프로그램에 따라서 대기시간이 달라짐

### SJF (Shortest-Job-First)

- 각 프로세스와 다음번 CPU burst time을 가지고 스케줄링에 활용하는 방식
- SJF is optimal : 주어진 프로세스들에 대해 minium average waiting time을 보장함
- 방식
    - non-preemptive : CPU burst가 완료될 수 있을 때까지 CPU 선점 당하지 않음
    - preemptive : SRTF (Shortest remaining time first) - 더 짧은 프로세스가 있다면 선점시키는 방식
- Problems
    - Starvation : 기아현상 - long process가 starvation(할당받지 못함)
    - CPU 사용시간을 알 수 없음 : process가 얼마나 쓰고 나갈지를 OS는 알 수 없음 (결정적이지 않기 떄문)
        - exponential averaging  방식 : 과거의 값을 토대로 다음번 시간을 예측하는 방식 (과거와 현재의 가중치 값이 있는데, 최근 것을 더 많이 반영하는 방식으로 함)

### Priority Scheduling

- 우선순위가 가장 높은 프로세스에게 CPU를 할당하는 방식
- 방식
    - PreemptiveNonpreemptive 방식 모두 존재함
- SJF도 우선순위 스케줄링의 일종
- 문제점 - SJF와 마찬가지로 starvation 문제가 있음 → aging (나이가 먹는 것) → 오래 기다리면 천천히 우선순위를 높혀주는 것 (경로사상..?)

### Round Robin (RR)

> Note : 현대 스케줄러의 기반
> 
- 각 프로세스는 동일한 크기의 할당 시간 (time quantum)을 가짐
- 할당 시간이 끝나게 되면 preemptive 당하고 뒤로 넘어가게 됨
- 장점
    - 응답시간이 빨라짐
    - (n-1)q time unit 이상으로 기다리지 않는다
- performance
    - q large → FIFO와 동일함
    - q small → context switch cost가 높음

### Multilevel Queue


- System → student 큐 순으로 우선순위 할당한다
- ready queue를 여러개로 분할
    - foreground → interactive
    - background → batch - no human interaction
- 큐마다 독립적으로 스케줄링 알고리즘을 가짐
    - foreground - RR
    - background - FCFS
    - 큐에 대한 스케줄링 필요
        - fixed priotity scheduling : foreground > background
            - possibility of starvation
        - time slice : CPU time을 적절한 ratio로 할당

### Multilevel Feedback Queue

- 프로세스가 다른 큐로 이동 가능
- 우선 첫 번쨰 빠른 응답 큐에서 FCFS방식으로 이동하는 방식 (aging 등을 이용하여)

### Multiple-Processor Scheduling

- Homogeneous processor : 한줄로 세워서 각 프로세서가 알아서 꺼내가는 방식
    - 어떤 잡이 항상 같은 CPU에서 실행되어야 하면 문제가 복잡해짐
- load sharing : 일부 프로세서에 job이 몰리지 않도록 적절히 공유하는 메커니즘 필요
- symmetric multiprocessing (SMP) : 각 프로세서가 각자 알아서 스케줄렁 결정
- asymmectric multi processing : 하나의 프로세서가 시스템의 데이터 접근, 공유를 책임지고 나머지 프로세서는 거기에 따름

### Real-Time Scheduling

- Hard real-time system : 정해진 시간 안에 반드시 끝나야하는 것
- Soft real-time computing : 일반 프로세스에 비해 높은 priotity를 갖도록 하는 것

### Thread Scheduling

- Local scheduling : user level thread - 사용자의 수준의 thread library에 의해 어떤 스레드를 스케줄링할지 프로그램이 결정함
- global scheduling : kernel level thread : 일반 프로세스와 마찬가지로 커널의 단기 스케줄러가 어떤 thread를 스케줄할지 결정함

## Algorithm Evaluation

- Queueing models : 확률 분포로 주어지는 arrival rate와 service rate등을 통해 performance index 값을 계산
- Implementation - Measurement : 실제 시스템에 알고리즘을 구현하여 실제 작업에 대해서 성능을 측정/비교
- simulation :알고리즘을 모의 프로그램으로 작성 후 trace를 입력으로 하여 결과 비교

# 6장 - Process Synchronization


- 여러 주체가 하나의 데이터를 접근하여 쓸 때 race condition이 발생할 수 있음

### Race condition - iterrupt handler


- interrupt가 있더라도 store가 될 떄까지 인터럽트를 잠시 비활성화 하는 것

### Race condition - User mode, Kernel mode가 switching 되는 경우 (Time sharing)

일반적인 프로세스

해결책 : kernel mode일 때에는 preempt 하지 않음.

### Race condition : multi processor

특정 커널 데이터에 대해서 lock / unlock을 걸어야함

### Process Synchronization 문제

- shared data에 대한 concurrent acces는 데이터의 inconsistency를 발생시킬 수 있다.
- consistency 유지를 위해서는 orderly execution 정해주는 매커니즘이 필요하다
- race condition : 여러 프로세스들이 동시에 공유 데이터를 접근하는 상황
- 해결책 - synchronize가 되어야

### The critical section problem

- n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우