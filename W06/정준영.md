# CH06

생성일: 2023년 1월 31일 오후 9:52

어떤 코드든 공유데이터를 접근 하거나 안하거나 로 나눌 수 있다.

S.W적으로 크리티컬섹션 접근 문제를 해결할 수 있다.

### 프로그램적 해결법의 충족조건

- **Mutual Exclusion (상호배제)**
  - 프로세스 A가 critical section 부분을 수행 중이면 다른 모든 프로세스들은 그들의 critical section에 들어가면 안된다.
  - entry section에서 이를 막아야 한다.
- **Progress(진행)**
  - 아무도 critical section에 있지 않은 상태에서 critical section에 들어가고자 하는 프로세스가 있으면 critical section에 들어가게 해주어야 한다.
  - 코드를 잘못짜면 동시에 접근시에 아무도 없는데 못들어가는 경우가 발생할 수 있다.
- **Bounded Wating**
  - 프로세스가 critical section에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 critical section에 들어가는 횟수에 한계가 있어야 한다.
  - 특정 프로세스가 너무 많이 기다리면 안된다. 크리티컬 섹션의 들어가고 싶어하는 프로세스가 여러개라면 기아현상이 발생하면 안된다. 계속 순서에서 밀리면 안됨.

++ 가정 : 모든 프로세스의 수행 속도는 0보다 크다. 프로세스들 간의 상대적인 수행 속도는 가정하지 않는다.

---

### Algorithm 1

크리티컬섹션에 진입 전 turn 변수로 순서를 체크해준다.

처음에는 turn을 0으로 세팅하고 시작. 이후 turn이 0이 아닌 동안에는 while문을 돌면서 계속 기다림. 이후 turn이 1로 바꾸는 순간(프로세스 1번이 바꿔줌) 크리티컬 섹션으로 들어감. 이후 다시 나오면 상대방차례로 1로 바꿔줌

turn으로 본인의 차례를 판단할 수 있다. turn으로 본인 차례가 아니라면 while문을 돌면서 기다리고 바뀌는 순간 입장이 가능하다.

→ 상호배제는 만족한다. 그러나 progress 조건은 만족하지 못함.

→ 어떤 프로세스가 크리티컬 섹션에 들어가야 상대에게 턴을 넘겨줄 수 있음. 극단적인 경우에는 상대방 프로세스가 턴을 넘겨주지 않으면 크리티컬 섹션에 들어가지 못할 수 있다.

---

### Algorithm 2

flag변수를 통해 크리티컬 섹션의 진입하고 싶은지 유무를 따진다.

크리티컬섹션에 진입하고 싶으면 flag값을 true로 설정한다.

이후 상대방이 flag를 세팅했는지 판단 후에 입장하고, 크리티컬 섹션 수행후 false로 바꾼다.

→ 둘다 끊임 없이 양보하는 상황 발생 가능. 즉 깃발만 들고 입장하지 못하는 상황이 생길 수 있다.

---

### Algorithm 3 (Peterson’s algorithm)

상대방이 flag를 세팅했고, 현재 turn이 상대방일때는 기다린다. 그러나 둘중 하나라도 만족하지 않는다면 나는 크리티컬 섹션에 입장할 수 있다.

- cpu를 중간에 빼앗기더라도 조건을 만족할수 있다.

그러나 **Busy Wating (= spin lock)** 문제점이 있다. 본인 cpu할당시간에 계속 while문만 도는 경우가 발생할 수 있다. 상대방이 while문을 허락해줘야 하기 때문이다.

---

### Synchronization Hardware

이런 문제가 생긴 이유는 어떤 데이터를 읽고, 쓰는 것이 하나의 명령어로 처리할 수 없기에 발생.

이것이 하나의 명령어로 해결할 수 있다면 문제가 발생하지 않는다.

즉, instruction 하나로 읽고, 쓰는것을 할 수 있다면 해결이 쉽게 가능하다.

Test_and_set으로 락이 0이라면 입장해서 크리티컬 섹션을 실행한다. 이때 Test_and_set으로 인해 락이 1로 바뀐다. 이후 다시 lock을 0(= false)으로 바꿔주는 작업을 해준다.

---

### Semaphores

- 앞의 방식들을 추상화시킴
- Semaphore **S**
  - integer variable
  - 아래의 두 가지 atomic 연산에 의해서만 접근 가능
    P(**S**)연산은 공유데이터를 획득하는 과정, V(**S**)연산은 반납하는 과정이다.
    P(**S**)연산 실행시 자원이 없는 경우 S값이 ≤ 0일때 자원 획득을 기다린다. 만약 가질 수 있으면 -연산을 하고 자원을 획득한다.
    V(**S**)연산은 공유데이터의 사용이 끝낫기에 자원획득을 반납하는 의미로 +를 해준다.
    Semaphore는 자원의 갯수라고 볼 수 있다.
    busy-wait방식 외에도 Block & Wakeup(=sleep lock) 방식으로 구현할 수도 있다.
    어차피 공유데이터에 접근을 못하면 블락시켜두는게 효율적이다. 굳이 계속 기다릴 필요 없음
  ***
  ### Block / Wakeup Implementation
  공유데이터에 접근을 못하는 프로세스를 블락시켜둔다.
  이를 wait queue에 넣어 관리한다.
  P연산에서 해당 프로세스의 세마포어 값이 음수라면(자원을 다 쓰고 있다는 의미) 해당 프로세스를 queue에 넣고 block()시킨다. V연산시에는 wakeup()연산으로 잠든 프로세스를 깨워주어야 한다.
  if문 설명 (이미 P연산시에 value를 - 하고 들어갔다. 그래서 ++시켜도 0이하라는건 깨워줄 프로세스가 있다는 의미다.)
  ***
  ### What is better?
  - Busy-wait vs Block.wakeup
  보통은 block and wakeup 방식이 좋다.
  그러나 critical section의 길이가 짧은 경우에는 busy-wait방식도 적당하다.(오버헤드 차이가 크지 않음)
  길이가 긴 경우에는 block and wake up이 효과적이다.
  ***
  ### Two Types of Semaphores
- Counting semaphore

  - 도메인이 0 이상인 임의의 정수값
  - 주로 resource counting에 사용

- Binary semaphore (=mutex)
  - 0 또는 1 값만 가질 수 있는 semaphore
  - 주로 mutual exclusion (lock/unlock)에 사용

---

### Deadlock and Starvation

- Deadlock
  - 둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 event를 무한히 기다리는 현상

2개가 모두 필요한 상황에서 하나씩 차지하고 상대방것을 요구하는 상태가 오면 데드락이 발생.

즉, 상대방이 가진것을 내놓으라 하면서 기다리는 상황. 자원 두개를 획득해서 반납하는 코드적 논리는 틀리지 않았다. 그러나 데드락 발생.

→ 자원 획득 순서를 일치시키면 문제를 해결할 수 있다.

- Starvation
  - indefineite blocking : 프로세스가 suspend된 이후에 해당하는 세마포어 큐에서 빠져나갈 수 없는 현상

---

### Classical Problems of Synchronization - 고전적인 동기화 문제

- Bounded-buffer problem
  버퍼의 크기가 유한한 환경에서 생산자,소비자 프로세스가 있는 상황에서 발생
  먼저, 프로세스가 생산자, 소비자로 나뉨. 각각의 프로세스들은 여러개가 있는 상황.
  생산자 : 공유버퍼에 데이터를 만들어서 넣는 역할을 함.
  소비자 : 공유버퍼의 데이터를 소비하는 역할을 함.
  **문제점**
  1. 생산자가 둘이 동시에 도착해서 같은 버퍼에 데이터를 집어 넣으려고 하면 문제가 발생.

  2. 소비자도 같은 버퍼에 접근해서 데이터를 가져오려 하면 문제 발생.

  3. 비어있는 버퍼가 없거나 차있는 버퍼가 없으면 문제가 생김 → 기다려야 한다.
  세마포어로 해야 할 업무
  1. 공유 버퍼에 락을 걸어 배타적 접근 문제
  2. 버퍼의 full or empty 유무에 따른 카운팅 세마포어 문제
  빈 버퍼가 있으면 획득한다. 0인경우 기다린다.
  획득 후 버퍼 전체에 락을 건다. mutex이용.
  이후 락을 푼다. 이후 내용이 들어있는 버퍼의 갯수를 증가시켜준다.(V)연산. 소비자에게 full연산은 기다리던 프로세스가 있는 경우 깨우는 신호
- Readers and writers problem

  read process , write process 두 종류가 있음.

  주로 DB에서 발생하기에 공유 데이터를 DB로 가정.

  Reader, Writer 는 여러개 있을 수 있음.

  - Solution : Writer가 접근을 안한 경우 Reader는 모두가 접근 가능. 그러나 Writer가 DB에 접근중이면 Reader의 접근은 금지
    읽는 작업은 동시에 해도 되는데 이렇게 lock을 걸면 1개의 processe만 접근 가능. 비효율적이다.
    readcount를 통해 몇개의 리더들이 읽고 있는지를 판단.
    최초의 reader라면 db의 락을 걸고, 아니라면 락을 걸 필요 없이 db를 읽기만 하면 됨.
    리드카운트 공유 변수도 동시에 접근시 문제가 발생할 수 있기에 락을 걸어주어야 한다.
    **문제**
    마지막 리더가 나갈때 까지 writer는 db접근을 못한다. 그리고 reader가 계속 들어오면 writer는 아예 db에 접근하지 못할 수 있는 문제 발생.
    <신호등 시스템으로 해결할 수 있음. 한번의 웨이브 단위로 처리.>

- Dining-Philosophers problem
  왼쪽, 오른쪽 젓가락을 잡아야 함. 그러나 젓가락은 공유자원이기에 잡을수 없는 상황이면 기다려야 한다.
  왼쪽 젓가락을 잡았으면 밥을 먹기전까지 놓지 않는다.
  문제점
  1. Deadlock의 문제점 → 모든 철학자가 동시에 배가 고파 왼쪽 젓가락을 집은 경우
  해결방안
  - 4명의 철학자만 테이블에 동시에 앉게 한다.
  - 젓가락을 두개 모두 집을 수 있을때 젓가락을 집을 수 있게 한다.
  - 비대칭 : 짝수 철학자는 왼쪽, 홀수 철학자는 오른쪽부터 집게 한다.

---

### Monitor

- Semaphore의 문제점
  - 코딩하기 힘들다
  - 정확성의 입증이 어렵다
  - 자발적 협력이 필요하다
  - 한번의 실수가 모든 시스템에 치명적 영향
- 즉, 실수로 인한 검증이 매우 어렵다

모니터를 통해서만 공유데이터에 접근할 수 있게 해준다.

프로그래머 입장에서는 락을 걸 필요가 없다. 모니터안에 넣어두면 모니터에 대한 동시접근을 허용하지 않기 때문이다.

모니터 내부에 공유데이터를 선언하고, 접근하기위한 procedure들은 내부 함수로 구현해 둔다.

- 모니터 내에서는 한번에 하나의 프로세스만이 활동 가능. → 즉, 생산자,소비자 이런 고민을 안해도 됨.
- 프로그래머가 동기화 제약 조건을 명시적으로 코딩할 필요 없음
- 프로세스가 모니터 안에서 기다릴 수 있도록 하기 위해
- condition variable 사용 → 값을 가지는것이 아닌 프로세스를 잠들게하고 깨우는 역할을 함
  - condition x, y;
  - condition 변수는 wait과 signal 연산에 의해서만 접근이 가능
  - x.wait() 을 invoke한 프로세스는 다른 프로세스가 x.signal을 invoke 하기 전까지 suspend된다.
  - x.signal()은 정확하게 하나의 suspend된 프로세스를 resume한다. suspend된 프로세스가 없으면 아무일도 일어나지 않는다.

---

## 예제
